From f983cb94178f5a894ea6f6017bc696833be5f213 Mon Sep 17 00:00:00 2001
From: SKumarMetro <s.kumar@metrological.com>
Date: Wed, 19 Dec 2018 10:03:03 -0800
Subject: [PATCH] [OCDM] Fix for playready encrypted stream issue on MIPS

---
 Source/core/DataElement.h | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/Source/core/DataElement.h b/Source/core/DataElement.h
index 72441f1..4a0431f 100644
--- a/Source/core/DataElement.h
+++ b/Source/core/DataElement.h
@@ -36,7 +36,7 @@ namespace Core {
         DataStore& operator= (const DataStore&) = delete;
 
     public:
-        DataStore(const uint32_t size = 1024) 
+        DataStore(const uint32_t size = 1024)
             : _size(size)
             , _buffer(reinterpret_cast<uint8_t*>(::malloc(size))) {
             ASSERT(_buffer != nullptr);
@@ -57,7 +57,7 @@ namespace Core {
                 ASSERT (offset + length <= _size);
 
                 uint32_t count (offset + length <= _size ? length : _size - offset);
-                
+
                 ::memcpy (&(_buffer[offset]), data, count);
             }
         }
@@ -82,7 +82,7 @@ namespace Core {
 
     private:
         uint32_t _size;
-        uint8_t* _buffer;    
+        uint8_t* _buffer;
     };
 
     class EXTERNAL DataElement {
@@ -218,7 +218,7 @@ namespace Core {
         {
             return (!operator==(RHS));
         }
- 
+
         virtual uint64_t Size() const
         {
             return (m_Size);
@@ -617,7 +617,7 @@ namespace Core {
             ASSERT((offset + size) <= m_Size);
 
             // Nope, one plain copy !!!
-            ::memcpy(&m_Buffer[offset], buffer, size);
+            ::memmove(&m_Buffer[offset], buffer, size);
         }
 
         bool Size(const uint64_t size)
@@ -647,10 +647,10 @@ namespace Core {
                 // We need to "extend" the buffer, this is only possible if we control
                 // the buffer lifetime..
                 // Create a new buffer
-		m_Storage->Size(static_cast<uint32_t>(size));
-		m_Buffer = &(m_Storage->Buffer()[static_cast<uint32_t>(m_Offset)]);
-		m_Size = size;
-		m_MaxSize = m_Storage->Size();
+        m_Storage->Size(static_cast<uint32_t>(size));
+        m_Buffer = &(m_Storage->Buffer()[static_cast<uint32_t>(m_Offset)]);
+        m_Size = size;
+        m_MaxSize = m_Storage->Size();
             }
         }
 
-- 
2.11.0

